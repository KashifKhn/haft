package {{.BasePackage}}.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
{{if .HasJpa}}
import {{.BasePackage}}.repository.{{.Name}}Repository;
import {{.BasePackage}}.entity.{{.Name}};
{{end}}
import {{.BasePackage}}.service.impl.{{.Name}}ServiceImpl;
import {{.BasePackage}}.mapper.{{.Name}}Mapper;
import {{.BasePackage}}.dto.{{.Name}}Request;
import {{.BasePackage}}.dto.{{.Name}}Response;

import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.never;

@ExtendWith(MockitoExtension.class)
@DisplayName("{{.Name}}Service Unit Tests")
class {{.Name}}ServiceTest {
{{if .HasJpa}}
    @Mock
    private {{.Name}}Repository {{.NameCamel}}Repository;
{{end}}
    @Mock
    private {{.Name}}Mapper {{.NameCamel}}Mapper;

    @InjectMocks
    private {{.Name}}ServiceImpl {{.NameCamel}}Service;

    private {{.Name}} {{.NameCamel}};
    private {{.Name}}Request request;
    private {{.Name}}Response response;
    private Long testId;

    @BeforeEach
    void setUp() {
        testId = 1L;
{{if .HasJpa}}
        {{.NameCamel}} = new {{.Name}}();
{{end}}
        request = new {{.Name}}Request();
        response = new {{.Name}}Response();
    }

    @Test
    @DisplayName("Should return all {{plural .NameLower}}")
    void shouldFindAll() {
{{if .HasJpa}}
        given({{.NameCamel}}Repository.findAll()).willReturn(List.of({{.NameCamel}}));
        given({{.NameCamel}}Mapper.toResponse(any({{.Name}}.class))).willReturn(response);

        List<{{.Name}}Response> result = {{.NameCamel}}Service.findAll();

        assertThat(result).hasSize(1);
        verify({{.NameCamel}}Repository).findAll();
{{else}}
        assertThatThrownBy(() -> {{.NameCamel}}Service.findAll())
                .isInstanceOf(UnsupportedOperationException.class);
{{end}}
    }

    @Test
    @DisplayName("Should find {{.NameLower}} by ID")
    void shouldFindById() {
{{if .HasJpa}}
        given({{.NameCamel}}Repository.findById(testId)).willReturn(Optional.of({{.NameCamel}}));
        given({{.NameCamel}}Mapper.toResponse({{.NameCamel}})).willReturn(response);

        {{.Name}}Response result = {{.NameCamel}}Service.findById(testId);

        assertThat(result).isNotNull();
        verify({{.NameCamel}}Repository).findById(testId);
{{else}}
        assertThatThrownBy(() -> {{.NameCamel}}Service.findById(testId))
                .isInstanceOf(UnsupportedOperationException.class);
{{end}}
    }

    @Test
    @DisplayName("Should throw exception when {{.NameLower}} not found by ID")
    void shouldThrowExceptionWhenNotFoundById() {
{{if .HasJpa}}
        given({{.NameCamel}}Repository.findById(testId)).willReturn(Optional.empty());

        assertThatThrownBy(() -> {{.NameCamel}}Service.findById(testId))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("not found");

        verify({{.NameCamel}}Mapper, never()).toResponse(any());
{{else}}
        assertThatThrownBy(() -> {{.NameCamel}}Service.findById(testId))
                .isInstanceOf(UnsupportedOperationException.class);
{{end}}
    }

    @Test
    @DisplayName("Should create new {{.NameLower}}")
    void shouldCreate() {
{{if .HasJpa}}
        given({{.NameCamel}}Mapper.toEntity(request)).willReturn({{.NameCamel}});
        given({{.NameCamel}}Repository.save({{.NameCamel}})).willReturn({{.NameCamel}});
        given({{.NameCamel}}Mapper.toResponse({{.NameCamel}})).willReturn(response);

        {{.Name}}Response result = {{.NameCamel}}Service.create(request);

        assertThat(result).isNotNull();
        verify({{.NameCamel}}Repository).save(any({{.Name}}.class));
{{else}}
        assertThatThrownBy(() -> {{.NameCamel}}Service.create(request))
                .isInstanceOf(UnsupportedOperationException.class);
{{end}}
    }

    @Test
    @DisplayName("Should update existing {{.NameLower}}")
    void shouldUpdate() {
{{if .HasJpa}}
        given({{.NameCamel}}Repository.findById(testId)).willReturn(Optional.of({{.NameCamel}}));
        given({{.NameCamel}}Repository.save({{.NameCamel}})).willReturn({{.NameCamel}});
        given({{.NameCamel}}Mapper.toResponse({{.NameCamel}})).willReturn(response);

        {{.Name}}Response result = {{.NameCamel}}Service.update(testId, request);

        assertThat(result).isNotNull();
        verify({{.NameCamel}}Mapper).updateEntity({{.NameCamel}}, request);
        verify({{.NameCamel}}Repository).save({{.NameCamel}});
{{else}}
        assertThatThrownBy(() -> {{.NameCamel}}Service.update(testId, request))
                .isInstanceOf(UnsupportedOperationException.class);
{{end}}
    }

    @Test
    @DisplayName("Should throw exception when updating non-existent {{.NameLower}}")
    void shouldThrowExceptionWhenUpdatingNonExistent() {
{{if .HasJpa}}
        given({{.NameCamel}}Repository.findById(testId)).willReturn(Optional.empty());

        assertThatThrownBy(() -> {{.NameCamel}}Service.update(testId, request))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("not found");

        verify({{.NameCamel}}Repository, never()).save(any());
{{else}}
        assertThatThrownBy(() -> {{.NameCamel}}Service.update(testId, request))
                .isInstanceOf(UnsupportedOperationException.class);
{{end}}
    }

    @Test
    @DisplayName("Should delete {{.NameLower}} by ID")
    void shouldDelete() {
{{if .HasJpa}}
        given({{.NameCamel}}Repository.existsById(testId)).willReturn(true);

        {{.NameCamel}}Service.delete(testId);

        verify({{.NameCamel}}Repository).deleteById(testId);
{{else}}
        assertThatThrownBy(() -> {{.NameCamel}}Service.delete(testId))
                .isInstanceOf(UnsupportedOperationException.class);
{{end}}
    }

    @Test
    @DisplayName("Should throw exception when deleting non-existent {{.NameLower}}")
    void shouldThrowExceptionWhenDeletingNonExistent() {
{{if .HasJpa}}
        given({{.NameCamel}}Repository.existsById(testId)).willReturn(false);

        assertThatThrownBy(() -> {{.NameCamel}}Service.delete(testId))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("not found");

        verify({{.NameCamel}}Repository, never()).deleteById(any());
{{else}}
        assertThatThrownBy(() -> {{.NameCamel}}Service.delete(testId))
                .isInstanceOf(UnsupportedOperationException.class);
{{end}}
    }
}
